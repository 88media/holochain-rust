# 15. Key Management

Date: 2018-09-27

## Status

In-Process

## Context

To deliver on Distributed Public Key Infrastructure that works in the context of both Holo and Holochain, we need a way to generate keys of various types (revocation, identity, enctryption, signing) from seeds, and we need to be able to generate such seeds from primary seeds, so that a human agent can create related "device agents" provably under their control.

To date, there we have done a bunch of work on DPKI, Personas, and hierarchical deterministic keys documented here:

 - Usage Story: https://hackmd.io/87H6J0pZSaG8MgbpnbjlIA
 - Long ADR draft: https://hackmd.io/VIVvRD9gQ5KnDy_C-y6leA
 - David's thoughts on DPKI: https://hackmd.io/2rDYowopS9OwRazptpQMYA

These documents detail various uses cases, including initial sign-up, key revocation, etc.  The central insight from this work is the need to create a Hierarchical Deterministic Key generation system, based on a Primary Seed, from which additional seeds can be generated which then are in turn used to actually generate many key-pairs.  This allows us, by-convention, to use the first seed generated by the Primary seed as the seed for revocation keys, and subsequent seeds as seeds for keys of separate Holochain devices that can be proven to be under the control of the holder of Primary Seed.

This ADR documents the synthesis of those documents in the form of functions that the Holochain core library needs to make available to container/composer developers as well as the app API needs to make available to DPKI holochain app developers via special capabilities.

These functions must provide the ability for associating key-pairs with a DPKI identity such that the private key never leaves the device it was generated on.

Libraries and standards exist for creating seeds and mnemonic word lists for those seeds.  These standards are in use with hardware wallets, that we may want Holo and Holochain to be able to interoperate with. Though there are some questions as to what degree this will be feasible given the rate and frequency that various Holochain processes need signing to happen which would make it impractical to keep having to do click on a hardware wallet.  I.e. any networking operation signing key cannot feasibly live on Trezor/Ledger.

Secp256k1 wasnâ€™t designed for encryption, but for signing, so at least some of our seeds and keys need to be generated using other standards.

### Illustrative Workflows

##### 1 - new / first holoport

```rust
// generate new random seed hierarchy
let hd = DpkiHd::new_random();

// display the primary/root seed to user for backup
display_to_user(Dpki::seed_to_mnemonic(hd.get_primary_seed()));

// publish to the dpki dht
let app_pub_data = DpkiApp::new_defaults(hd);
publish_to_dpki_dht(app_pub_data);

// initialize a device structure with device seed number 1
let device = DpkiDevice::new_from_seed(hd.get_device_seed(1));
// (optional) display device seed to user for backup
display_to_user(Dpki::seed_to_mnemonic(hd.get_device_seed(1)));
// blink the device pin on the holoport circle
display_to_user(device.get_device_pin());

// reboot will require passphrase re-entry
save_to_disk(device.get_saved(prompt_user_for_passphrase()));
```

##### 2 - existing holoport identity to a new box (device mnemonic)

```rust
// generate device dpki from user input
let device = DpkiDevice::new_from_seed_and_pin(
    Dpki::mnemonic_to_seed(prompt_user_for_device_seed()),
    prompt_user_for_pin());

// reboot will require passphrase re-entry
save_to_disk(device.get_saved(prompt_user_for_passphrase()));
```

##### 3 - existing holoport identity to a new box (primary/root mnemonic)

```rust
// generate seed hierarchy from backup primary/root seed
let hd = DpkiHd::new_from_primary_seed(
    Dpki::mnemonic_to_seed(prompt_user_for_primary_seed()));

// generate device dpki from user input
let device = DpkiDevice::new_from_seed_and_pin(
    hd.get_device_seed(prompt_user_for_device_index()),
    prompt_user_for_pin());

// reboot will require passphrase re-entry
save_to_disk(device.get_saved(prompt_user_for_passphrase()));
```

##### 4 - new box / device generated keys - connect to existing dpki identity

```rust
// generate new random seed hierarchy
let hd = DpkiHd::new_random();

// display the primary/root seed to user for backup
display_to_user(Dpki::seed_to_mnemonic(hd.get_primary_seed()));

// attach to existing identitiy
let existing_app_pub_data = DpkiApp::fetch(
    prompt_user_for_dpki_id());
existing_app_pub_data.request_authorize_new_keys(hd);
// user will need to sign the new keys into their chain from
// another device that is already authorized

// initialize a device structure with device seed number 1
let device = DpkiDevice::new_from_seed(hd.get_device_seed(1));
// (optional) display device seed to user for backup
display_to_user(Dpki::seed_to_mnemonic(hd.get_device_seed(1)));
// blink the device pin on the holoport circle
display_to_user(device.get_device_pin());

// reboot will require passphrase re-entry
save_to_disk(device.get_saved(prompt_user_for_passphrase()));
```

##### 5 - new holo identity

```rust
// will generate a new random salt and password hash it
// to form a seed for keypair generation
let holo = DpkiHolo::new_random_from_passphrase(
    prompt_user_for_passphrase());

// publish on dpki dht
let app_pub_data = DpkiApp::new_holo(
    prompt_user_for_username(),
    holo);
publish_to_dpki_dht(app_pub_data);

// init a device object for signing / encryption
let device = DpkiDevice::new_from_holo(holo);
```

##### 6 - restore holo identity

```rust
// we need to fetch the distributed salt
// in order to restore our private keys
let username = prompt_user_for_username();
let app_pub_data = DpkiApp::fetch(
    lookup_dpki_id(username));

// generate the same seed data / private keys from salt / passphrase
let holo = DpkiHolo::new_from_salt_passphrase(
    app_pub_data.get_salt_for_username(username),
    prompt_user_for_passphrase());

// init a device object for signing / encryption
let device = DpkiDevice::new_from_holo(holo);
```

## Decision

We will use the [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) standard for generating mnemonic word lists from seeds  [Rust crate is available.](https://github.com/infincia/bip39-rs)

We will use [libsodium](https://download.libsodium.org/doc/) as our primary library for encryption, decryption, signatures, password hashing, etc..

We will use this api sketch as a starting point for implementation in the `holochain_api` crate, i.e. for use by container/composer developers:

```rust
/// utilities for working with mnemonic word lists
pub mod Dpki {
    fn seed_to_mnemonic(seed: &[u8; 32]) -> String;
    fn mnemonic_to_seed(mnemonic: &str) -> [u8; 32];
}

/// struct for hd seed derivation handling
impl DpkiHd {
    pub fn new_random() -> Self;
    pub fn new_from_primary_seed(primary_seed: &[u8; 32]) -> Self;
    pub fn get_primary_seed(&self) -> [u8; 32];
    pub fn get_revoke_seed(&self) -> [u8; 32];
    pub fn get_device_seed(&self, index: u64) -> [u8; 32];
}

/// struct for managing keypair seeds with salt / passphrase
impl DpkiHolo {
    pub fn new_random_from_passphrase(passphrase: &str) -> Self;
    pub fn new_from_salt_passphrase(
        salt: &[u8; 32], passphrase: &str) -> Self;
    pub fn get_salt(&self) -> [u8; 32];
}

/// struct for an individual device's usage of crypto
impl DpkiDevice {
    pub fn new_from_holo(holo: &DpkiHolo) -> Self;
    pub fn new_from_seed(device_seed: &[u8; 32]) -> Self;
    pub fn new_from_seed_and_pin(device_seed: &[u8; 32], device_pin: &str) -> Self;
    pub fn new_from_saved(data: &[u8], passphrase: &str) -> Self;
    pub fn get_saved(&self, passphrase: &str) -> Vec<u8>;
    pub fn get_device_pin(&self) -> String;
    pub fn get_sign_author_public_key(&self) -> [u8; 32];
    pub fn get_sign_network_public_key(&self) -> [u8; 32];
    pub fn get_encrypt_public_key(&self) -> [u8; 32];
    // ... additional functions for actual signing / encryption
}

/// struct for managing the distributed public data
/// associated with a user's identity
impl DpkiApp {
    pub fn new_defaults(hd_priv: &DpkiHd) -> Self;
    pub fn new_holo(username: &str, holo: &DpkiHolo) -> Self;
    pub fn fetch(identity: String) -> Self;
    pub fn request_authorize_new_keys(hd_priv: &DpkiHd);
    // ... additional functions for managing revokations / etc...
}
```

### Note 1:

Making use of the HD Heirarchy, the derivation paths will follow:
- primary/root: `[]` (i.e. no derivation)
- revokeN: `[0, N]` (probably will only ever generate 1)
- deviceN-author: `[1,N,/**PIN/,0]`
- deviceN-network: `[1,N,/**PIN/,1]`

### Note 2:
PIN derivations (`/**PIN/`) do not use the standard derivation path, but rather take the previous seed as salt, applying a password hash with the PIN to guard brute-force attacks. The PIN itself is 6 - 12 digits from 1-9 inclusive. This allows us to arrange a randomly positioned 3x3 grid for PIN entry in order to obfuscate against malware on comprimised entry devices.

### Note 3:
The same functions will be made available in the HDK but are only allowed to be called by functions exposed through a system defined `key_management` capability, i.e. for use by DPKI app developers, however only a private_key_handle will be returned, which is only valid inside that one app, i.e. it will not work if sent to another node via a network or even via bridging.

## Consequences

- We need to determine how to choose a derivation path for use with hierarchical deterministic key standards.
- We propose that for simplicity we stick with 32 byte seeds (and therefore 24 word mnemonics) at all levels.
- A prerequisite for these functions to get implemented is a bunch of work on capabilities in `holochain-rust`.
- We may need to add a ``key_version_index`` field into chain entry headers to rapidly find which key was used for signing the header/entry pair (by following key chain  haha)
